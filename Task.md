# Инкремент 1

Чтобы написать сервис, который будет сжимать длинные URL до нескольких символов, для начала вам нужно разработать сервер.
Сервер должен быть доступен по адресу http://localhost:8080 и предоставлять два эндпоинта:
Эндпоинт с методом `POST` и путём `/`. Сервер принимает в теле запроса строку URL как `text/plain` 
и возвращает ответ с кодом 201 и сокращённым URL как text/plain.

Пример запроса к серверу:

```
POST / HTTP/1.1
Host: localhost:8080
Content-Type: text/plain

https://practicum.yandex.ru/
```

Пример ответа от сервера:

```
HTTP/1.1 201 Created
Content-Type: text/plain
Content-Length: 30

http://localhost:8080/EwHXdJfB
```

Эндпоинт с методом `GET` и путём `/{id}`, где `id` — идентификатор сокращённого URL (например, `/EwHXdJfB`). 
В случае успешной обработки запроса сервер возвращает ответ с кодом `307` и оригинальным URL в HTTP-заголовке `Location`.

Пример запроса к серверу:

```
GET /EwHXdJfB HTTP/1.1
Host: localhost:8080
Content-Type: text/plain
Пример ответа от сервера:
```

Пример ответа от сервера:

```
HTTP/1.1 307 Temporary Redirect
Location: https://practicum.yandex.ru/
``` 

На любой некорректный запрос сервер должен возвращать ответ с кодом `400`.

# Инкремент 2

Покройте сервис unit-тестами. 
Сконцентрируйтесь на покрытии тестами функций-обработчиков
(хэндлеров, которых пока два), чтобы защитить API сервиса от случайных изменений.

# Инкремент 3

Вы написали приложение с помощью пакета стандартной библиотеки net/http. 
Используя любой внешний пакет (роутер или фреймворк), совместимый с net/http, перепишите ваш код.
Задача направлена на рефакторинг приложения с помощью готовой библиотеки.
Обратите внимание, что необязательно запускать приложение вручную: тесты, которые вы написали до этого, 
помогут вам в рефакторинге.

# Инкремент 4

Добавьте возможность конфигурировать сервис с помощью аргументов командной строки.

Создайте конфигурацию или переменные для запуска со следующими флагами:
- Флаг `-a` отвечает за адрес запуска HTTP-сервера (значение может быть таким: `localhost:8888`).
- Флаг `-b` отвечает за базовый адрес результирующего сокращённого URL
(значение: адрес сервера перед коротким URL, например, `http://localhost:8000/qsd54gFg`).

**Совет:** создайте отдельный пакет config, где будет храниться структура с вашей конфигурацией и функция, 
которая будет инициализировать поля этой структуры.
По мере усложнения конфигурации вы сможете добавлять необходимые поля в вашу структуру и инициализировать их.

# Инкремент 5

Добавьте возможность конфигурировать сервис с помощью переменных окружения:
- Адрес запуска HTTP-сервера — с помощью переменной `SERVER_ADDRESS`.
- Базовый адрес результирующего сокращённого URL — с помощью переменной `BASE_URL`.

Приоритет параметров сервера должен быть таким:
- Если указана переменная окружения, то используется она.
- Если нет переменной окружения, но есть аргумент командной строки (флаг), то используется он.
- Если нет ни переменной окружения, ни флага, то используется значение по умолчанию.

# Инкремент 6

Реализуйте логирование сведений о запросах и ответах на сервере для всех эндпоинтов, которые у вас уже есть.
- Сведения о запросах должны содержать URI, метод запроса и время, затраченное на его выполнение.
- Сведения об ответах должны содержать код статуса и размер содержимого ответа.

Эту функциональность нужно реализовать через middleware. Используйте один из сторонних пакетов для логирования:
- github.com/rs/zerolog,
- go.uber.org/zap,
- github.com/sirupsen/logrus.

Все сообщения логгера должны быть на уровне `Info`.

# Инкремент 7

Добавьте в код сервера новый эндпоинт `POST /api/shorten`, который будет принимать в теле запроса
JSON-объект
```json
{
    "url": "<some_url>"
}
``` 
и возвращать в ответ объект
```json
{
  "result": "<short_url>"
}
```

Запрос может иметь такой вид:

```http request
POST http://localhost:8080/api/shorten HTTP/1.1
Host: localhost:8080
Content-Type: application/json

{
    "url": "https://practicum.yandex.ru"
}
```

Ответ может быть таким:

```
HTTP/1.1 201 OK
Content-Type: application/json
Content-Length: 30

{
    "result": "http://localhost:8080/EwHXdJfB"
}
```

Удостоверьтесь, что в ответе от сервера присутствует HTTP-заголовок `Content-Type` со значением `application/json`.
Он указывает клиенту, в каком формате передано тело ответа.

Также не забудьте добавить тесты на новый эндпоинт, как и на предыдущие.

При реализации задействуйте одну из распространённых библиотек:
- encoding/json
- github.com/mailru/easyjson
- github.com/pquerna/ffjson
- github.com/labstack/echo
- github.com/goccy/go-json

# Инкремент 8

Добавьте поддержку `gzip` в ваш сервис. 
Научите его:
- Принимать запросы в сжатом формате (с HTTP-заголовком `Content-Encoding`).
- Отдавать сжатый ответ клиенту, который поддерживает обработку сжатых ответов (с HTTP-заголовком `Accept-Encoding`).

Функция сжатия должна работать для контента с типами `application/json` и `text/html`.

Вспомните middleware из урока про HTTP-сервер, это может вам помочь.

# Инкремент 9

Сохраните все сокращённые URL на диск в виде файла. 

При перезапуске сервера все URL должны быть восстановлены.

Сервер должен принимать соответствующие параметры конфигурации через флаги и переменные окружения:
- Флаг `-f`, переменная окружения `FILE_STORAGE_PATH` — путь до файла, куда сохраняются данные в формате JSON. 
Имя файла для значения по умолчанию придумайте сами.

Пример содержимого файла:

```json lines
[
    {"uuid":"1","short_url":"4rSPg8ap","original_url":"http://yandex.ru"},
    {"uuid":"2","short_url":"edVPg3ks","original_url":"http://ya.ru"},
    {"uuid":"3","short_url":"dG56Hqxm","original_url":"http://practicum.yandex.ru"},
    ...
]
```

Приоритет параметров сервера должен быть таким:
- Если указана переменная окружения, то используется она.
- Если нет переменной окружения, но есть флаг, то используется он.
- Если нет ни переменной окружения, ни флага, то используется значение по умолчанию.

# Инкремент 10

- Добавьте в сервис функциональность подключения к базе данных. 
В качестве СУБД используйте PostgreSQL не ниже 10 версии.

- Добавьте в сервис хендлер `GET /ping`, который при запросе проверяет соединение с базой данных. 
При успешной проверке хендлер должен вернуть HTTP-статус `200 OK`, при неуспешной — `500 Internal Server Error`.

Строка с адресом подключения к БД должна получаться из переменной окружения `DATABASE_DSN` или флага командной строки `-d`.

Для работы с БД используйте один из следующих пакетов:
- database/sql,
- github.com/jackc/pgx,
- github.com/lib/pq,
- github.com/jmoiron/sqlx.

# Инкремент 11

Доработайте сервис и добавьте поддержку СУБД PostgreSQL для хранения сокращённых URL.

Сервису нужно самостоятельно создать все необходимые таблицы в базе данных.

Схема и формат хранения остаются на ваше усмотрение.

Используйте инструмент миграций для создания и изменения схемы базы данных.

При отсутствии переменной окружения `DATABASE_DSN` или флага командной строки `-d` либо при их пустых значениях, вернитесь последовательно к:
- хранению сокращённых URL в файле — при наличии соответствующей переменной окружения или флага командной строки;
- хранению сокращённых URL в памяти.

# Инкремент 12

Добавьте новый хендлер `POST /api/shorten/batch`, принимающий в теле запроса множество URL для сокращения в формате:

```json lines
[
    {
        "correlation_id": "<строковый идентификатор>",
        "original_url": "<URL для сокращения>"
    },
    ...
]
```
В качестве ответа хендлер должен возвращать данные в формате:

```json lines
[
    {
        "correlation_id": "<строковый идентификатор из объекта запроса>",
        "short_url": "<результирующий сокращённый URL>"
    },
    ...
]
```
Все записи о коротких URL сохраняйте в базе данных. 
Не забудьте добавить реализацию для сохранения в файл и в память.
Стоит помнить, что:
- нужно соблюдать обратную совместимость;
- отправлять пустые батчи не нужно;
- вы умеете сжимать контент по алгоритму gzip;
- изменение в базе можно выполнять в рамках одной транзакции или одного запроса;
- необходимо избегать формирования условий для возникновения состояния гонки (race condition).

# Инкремент 13

Сделайте в таблице базы данных с сокращёнными URL уникальный индекс для поля с исходным URL. 
Это позволит избавиться от дублирующих записей в БД.
Используйте инструмент миграций для изменения схемы базы данных.

При попытке пользователя сократить уже имеющийся в базе URL через хендлеры `POST /` и `POST /api/shorten` сервис должен вернуть HTTP-статус `409 Conflict`, 
а в теле ответа — уже имеющийся сокращённый URL в правильном для хендлера формате.

Стратегии реализации:
1. Чтобы не проверять наличие оригинального URL в базе данных отдельным запросом, 
можно воспользоваться конструкцией `INSERT ... ON CONFLICT` в PostgreSQL. 
Однако в таком случае придётся самостоятельно возвращать и проверять собственную ошибку.
1. Чтобы определить тип ошибки PostgreSQL, с которой завершился запрос, можно воспользоваться библиотекой github.com/jackc/pgerrcode, 
в частности `pgerrcode.UniqueViolation`. В таком случае придётся делать дополнительный запрос к хранилищу, чтобы определить сокращённый вариант URL.

# Инкремент 14

Добавьте в сервис функциональность аутентификации пользователя.

Сервис должен:
- Выдавать пользователю симметрично подписанную куку, содержащую уникальный идентификатор пользователя, 
если такой куки не существует или она не проходит проверку подлинности.
- Иметь хендлер `GET /api/user/urls`, который сможет вернуть пользователю все когда-либо сокращённые им URL в формате:

```json lines
[
    {
        "short_url": "https://...",
        "original_url": "https://..."
    },
    ...
]
```

- Если кука присутствует в запросе, но не содержит ID пользователя, хендлер должен возвращать HTTP-статус 401 Unauthorized.
- При отсутствии сокращённых пользователем URL хендлер должен отдавать HTTP-статус 204 No Content.

Получить куки запроса можно из поля `(*http.Request).Cookie()`, а установить — методом `http.SetCookie()`.

# Инкремент 15 

Сделайте в таблице базы данных с сокращёнными URL дополнительное поле с флагом, 
указывающим на то, что URL должен считаться удалённым. Например, так:

```go
type Storage struct {
    UUID          string  `db:"user_id"`
    ShortURL      string  `db:"short_url"`
    OriginslURL   string  `db:"original_url"`
    DeletedFlag   bool    `db:"is_deleted"`
}
```

Добавьте в сервис новый хендлер `DELETE /api/user/urls`, 
который в теле запроса принимает список идентификаторов сокращённых URL для асинхронного удаления. 
Запрос может быть таким:

```http request
DELETE http://localhost:8080/api/user/urls
Content-Type: application/json

["6qxTVvsy", "RTfd56hn", "Jlfd67ds"]
```

В случае успешного приёма запроса хендлер должен возвращать HTTP-статус `202 Accepted`. 
Фактический результат удаления может происходить позже — оповещать пользователя об успешности или неуспешности не нужно.

Успешно удалить URL может пользователь, его создавший. 
При запросе удалённого URL с помощью хендлера `GET /{id}` нужно вернуть статус `410 Gone`.

Совет:
- Для эффективного проставления флага удаления в БД используйте множественное обновление (batch update).
- Для максимального наполнения буфера объектов обновления используйте паттерн `fanIn`.

# Инкремент 16

С помощью паттерна «Наблюдатель» добавьте в сервис функциональность аудита запросов.
Добавьте в сервер параметры конфигурации:
- Флаг `--audit-file`, переменная окружения `AUDIT_FILE` — путь к файлу-приёмнику, в который сохраняются логи аудита. 
Если параметр не передан, аудит в файл должен быть отключён.
- Флаг `--audit-url`, переменная окружения `AUDIT_URL` — полный URL удаленного сервера-приёмника, куда отправляются логи аудита. 
Если параметр не передан, аудит на удалённый сервер должен быть отключён.

Формат события аудита:
```json lines
{
    "ts": 12345678, // unix timestamp события
    "action": "shorten", // действие: shorten (создание) или follow (прохождение по ссылке)
    "user_id": "12315134", // идентификатор пользователя, если есть
    "url": "https://mylongdomain.com/my/long/path/to/shorten/" // оригинальный (не сокращенный) URL
}
```

Аудитом должны быть покрыты следующие хэндлеры:
- `POST /`
- `POST /api/shorten`
- `GET /{id}`

После успешной обработки запроса к любому из хэндлеров необходимо сформировать сообщение события аудита 
и отправить его во все доступные приёмники аудита.

Для файла-приёмника добавление происходит в конец файла, указанного в параметре конфигурации, 
на новой строке.

Для удалённого сервера-приёмника отсылка выполняется методом `POST` по URL, 
указанному в параметре конфигурации.

# Инкремент 17

Вы писали код в течение нескольких спринтов. 
Сейчас самое время задать себе вопрос: что можно улучшить в производительности и эффективности вашей системы?

Этот инкремент посвящён измерению, анализу и оптимизации: не предполагаем, а проверяем, 
где именно тратятся ресурсы — процессорное время, память — и как сделать проект лучше.

--- 

Добавьте в свой проект бенчмарки, измеряющие скорость выполнения важнейших компонентов вашей системы.

Проведите анализ использования памяти вашим проектом, 
определите и исправьте неэффективные части кода по следующему алгоритму:
1. Используя профилировщик `pprof`, 
сохраните профиль потребления памяти вашим проектом в директорию `profiles` с именем `base.pprof`
2. Изучите полученный профиль:
   - используйте команды `top`, `list`, `web`, `peek` в `pprof`;
   - обратите внимание на количество аллокаций, удерживаемую память и «тяжёлые» функции.
3. Оптимизируйте код, убрав избыточные аллокации или переписав неэффективные участки кода
4. Снимите профиль повторно, сохраните его как `profiles/result.pprof`

Проверьте результат внесённых изменений командой:
```shell
pprof -top -diff_base=profiles/base.pprof profiles/result.pprof
```

Если всё сделано правильно, вы увидите отрицательные значения — показатель того, что использование памяти уменьшилось. 
Добавьте полученный вывод в `README.md`.

## Рекомендации

- Подготовьте тестовые данные, чтобы система обрабатывала непустой и реалистичный набор входных данных.
- Эмулируйте нагрузку, например, используйте инструменты вроде hey, wrk или ab.
- Снимайте профиль во время или сразу после нагрузки, когда память уже занята.

# Инкремент 18

Отформатируйте свой проект с помощью `gofmt` или `goimports`. Убедитесь, что все файлы проекта прошли форматирование.