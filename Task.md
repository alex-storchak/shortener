# Инкремент 1

Чтобы написать сервис, который будет сжимать длинные URL до нескольких символов, для начала вам нужно разработать сервер.
Сервер должен быть доступен по адресу http://localhost:8080 и предоставлять два эндпоинта:
Эндпоинт с методом `POST` и путём `/`. Сервер принимает в теле запроса строку URL как `text/plain` 
и возвращает ответ с кодом 201 и сокращённым URL как text/plain.

Пример запроса к серверу:

```
POST / HTTP/1.1
Host: localhost:8080
Content-Type: text/plain

https://practicum.yandex.ru/
```

Пример ответа от сервера:

```
HTTP/1.1 201 Created
Content-Type: text/plain
Content-Length: 30

http://localhost:8080/EwHXdJfB
```

Эндпоинт с методом `GET` и путём `/{id}`, где `id` — идентификатор сокращённого URL (например, `/EwHXdJfB`). 
В случае успешной обработки запроса сервер возвращает ответ с кодом `307` и оригинальным URL в HTTP-заголовке `Location`.

Пример запроса к серверу:

```
GET /EwHXdJfB HTTP/1.1
Host: localhost:8080
Content-Type: text/plain
Пример ответа от сервера:
```

Пример ответа от сервера:

```
HTTP/1.1 307 Temporary Redirect
Location: https://practicum.yandex.ru/
``` 

На любой некорректный запрос сервер должен возвращать ответ с кодом `400`.

# Инкремент 2

Покройте сервис unit-тестами. 
Сконцентрируйтесь на покрытии тестами функций-обработчиков
(хэндлеров, которых пока два), чтобы защитить API сервиса от случайных изменений.

# Инкремент 3

Вы написали приложение с помощью пакета стандартной библиотеки net/http. 
Используя любой внешний пакет (роутер или фреймворк), совместимый с net/http, перепишите ваш код.
Задача направлена на рефакторинг приложения с помощью готовой библиотеки.
Обратите внимание, что необязательно запускать приложение вручную: тесты, которые вы написали до этого, 
помогут вам в рефакторинге.

# Инкремент 4

Добавьте возможность конфигурировать сервис с помощью аргументов командной строки.

Создайте конфигурацию или переменные для запуска со следующими флагами:
- Флаг `-a` отвечает за адрес запуска HTTP-сервера (значение может быть таким: `localhost:8888`).
- Флаг `-b` отвечает за базовый адрес результирующего сокращённого URL
(значение: адрес сервера перед коротким URL, например, `http://localhost:8000/qsd54gFg`).

**Совет:** создайте отдельный пакет config, где будет храниться структура с вашей конфигурацией и функция, 
которая будет инициализировать поля этой структуры.
По мере усложнения конфигурации вы сможете добавлять необходимые поля в вашу структуру и инициализировать их.

# Инкремент 5

Добавьте возможность конфигурировать сервис с помощью переменных окружения:
- Адрес запуска HTTP-сервера — с помощью переменной `SERVER_ADDRESS`.
- Базовый адрес результирующего сокращённого URL — с помощью переменной `BASE_URL`.

Приоритет параметров сервера должен быть таким:
- Если указана переменная окружения, то используется она.
- Если нет переменной окружения, но есть аргумент командной строки (флаг), то используется он.
- Если нет ни переменной окружения, ни флага, то используется значение по умолчанию.

# Инкремент 6

Реализуйте логирование сведений о запросах и ответах на сервере для всех эндпоинтов, которые у вас уже есть.
- Сведения о запросах должны содержать URI, метод запроса и время, затраченное на его выполнение.
- Сведения об ответах должны содержать код статуса и размер содержимого ответа.

Эту функциональность нужно реализовать через middleware. Используйте один из сторонних пакетов для логирования:
- github.com/rs/zerolog,
- go.uber.org/zap,
- github.com/sirupsen/logrus.

Все сообщения логгера должны быть на уровне `Info`.

# Инкремент 7

Добавьте в код сервера новый эндпоинт `POST /api/shorten`, который будет принимать в теле запроса
JSON-объект
```json
{
    "url": "<some_url>"
}
``` 
и возвращать в ответ объект
```json
{
  "result": "<short_url>"
}
```

Запрос может иметь такой вид:

```http request
POST http://localhost:8080/api/shorten HTTP/1.1
Host: localhost:8080
Content-Type: application/json

{
    "url": "https://practicum.yandex.ru"
}
```

Ответ может быть таким:

```
HTTP/1.1 201 OK
Content-Type: application/json
Content-Length: 30

{
    "result": "http://localhost:8080/EwHXdJfB"
}
```

Удостоверьтесь, что в ответе от сервера присутствует HTTP-заголовок `Content-Type` со значением `application/json`.
Он указывает клиенту, в каком формате передано тело ответа.

Также не забудьте добавить тесты на новый эндпоинт, как и на предыдущие.

При реализации задействуйте одну из распространённых библиотек:
- encoding/json
- github.com/mailru/easyjson
- github.com/pquerna/ffjson
- github.com/labstack/echo
- github.com/goccy/go-json

# Инкремент 8

Добавьте поддержку `gzip` в ваш сервис. 
Научите его:
- Принимать запросы в сжатом формате (с HTTP-заголовком `Content-Encoding`).
- Отдавать сжатый ответ клиенту, который поддерживает обработку сжатых ответов (с HTTP-заголовком `Accept-Encoding`).

Функция сжатия должна работать для контента с типами `application/json` и `text/html`.

Вспомните middleware из урока про HTTP-сервер, это может вам помочь.

# Инкремент 9

Сохраните все сокращённые URL на диск в виде файла. 

При перезапуске сервера все URL должны быть восстановлены.

Сервер должен принимать соответствующие параметры конфигурации через флаги и переменные окружения:
- Флаг `-f`, переменная окружения `FILE_STORAGE_PATH` — путь до файла, куда сохраняются данные в формате JSON. 
Имя файла для значения по умолчанию придумайте сами.

Пример содержимого файла:

```json lines
[
    {"uuid":"1","short_url":"4rSPg8ap","original_url":"http://yandex.ru"},
    {"uuid":"2","short_url":"edVPg3ks","original_url":"http://ya.ru"},
    {"uuid":"3","short_url":"dG56Hqxm","original_url":"http://practicum.yandex.ru"},
    ...
]
```

Приоритет параметров сервера должен быть таким:
- Если указана переменная окружения, то используется она.
- Если нет переменной окружения, но есть флаг, то используется он.
- Если нет ни переменной окружения, ни флага, то используется значение по умолчанию.

# Инкремент 10

- Добавьте в сервис функциональность подключения к базе данных. 
В качестве СУБД используйте PostgreSQL не ниже 10 версии.

- Добавьте в сервис хендлер `GET /ping`, который при запросе проверяет соединение с базой данных. 
При успешной проверке хендлер должен вернуть HTTP-статус `200 OK`, при неуспешной — `500 Internal Server Error`.

Строка с адресом подключения к БД должна получаться из переменной окружения `DATABASE_DSN` или флага командной строки `-d`.

Для работы с БД используйте один из следующих пакетов:
- database/sql,
- github.com/jackc/pgx,
- github.com/lib/pq,
- github.com/jmoiron/sqlx.

# Инкремент 11

Доработайте сервис и добавьте поддержку СУБД PostgreSQL для хранения сокращённых URL.

Сервису нужно самостоятельно создать все необходимые таблицы в базе данных.

Схема и формат хранения остаются на ваше усмотрение.

Используйте инструмент миграций для создания и изменения схемы базы данных.

При отсутствии переменной окружения `DATABASE_DSN` или флага командной строки `-d` либо при их пустых значениях, вернитесь последовательно к:
- хранению сокращённых URL в файле — при наличии соответствующей переменной окружения или флага командной строки;
- хранению сокращённых URL в памяти.

# Инкремент 12

Добавьте новый хендлер `POST /api/shorten/batch`, принимающий в теле запроса множество URL для сокращения в формате:

```json lines
[
    {
        "correlation_id": "<строковый идентификатор>",
        "original_url": "<URL для сокращения>"
    },
    ...
]
```
В качестве ответа хендлер должен возвращать данные в формате:

```json lines
[
    {
        "correlation_id": "<строковый идентификатор из объекта запроса>",
        "short_url": "<результирующий сокращённый URL>"
    },
    ...
]
```
Все записи о коротких URL сохраняйте в базе данных. 
Не забудьте добавить реализацию для сохранения в файл и в память.
Стоит помнить, что:
- нужно соблюдать обратную совместимость;
- отправлять пустые батчи не нужно;
- вы умеете сжимать контент по алгоритму gzip;
- изменение в базе можно выполнять в рамках одной транзакции или одного запроса;
- необходимо избегать формирования условий для возникновения состояния гонки (race condition).

# Инкремент 13

Сделайте в таблице базы данных с сокращёнными URL уникальный индекс для поля с исходным URL. 
Это позволит избавиться от дублирующих записей в БД.
Используйте инструмент миграций для изменения схемы базы данных.

При попытке пользователя сократить уже имеющийся в базе URL через хендлеры `POST /` и `POST /api/shorten` сервис должен вернуть HTTP-статус `409 Conflict`, 
а в теле ответа — уже имеющийся сокращённый URL в правильном для хендлера формате.

Стратегии реализации:
1. Чтобы не проверять наличие оригинального URL в базе данных отдельным запросом, 
можно воспользоваться конструкцией `INSERT ... ON CONFLICT` в PostgreSQL. 
Однако в таком случае придётся самостоятельно возвращать и проверять собственную ошибку.
1. Чтобы определить тип ошибки PostgreSQL, с которой завершился запрос, можно воспользоваться библиотекой github.com/jackc/pgerrcode, 
в частности `pgerrcode.UniqueViolation`. В таком случае придётся делать дополнительный запрос к хранилищу, чтобы определить сокращённый вариант URL.

# Инкремент 14

Добавьте в сервис функциональность аутентификации пользователя.

Сервис должен:
- Выдавать пользователю симметрично подписанную куку, содержащую уникальный идентификатор пользователя, 
если такой куки не существует или она не проходит проверку подлинности.
- Иметь хендлер `GET /api/user/urls`, который сможет вернуть пользователю все когда-либо сокращённые им URL в формате:

```json lines
[
    {
        "short_url": "https://...",
        "original_url": "https://..."
    },
    ...
]
```

- Если кука присутствует в запросе, но не содержит ID пользователя, хендлер должен возвращать HTTP-статус 401 Unauthorized.
- При отсутствии сокращённых пользователем URL хендлер должен отдавать HTTP-статус 204 No Content.

Получить куки запроса можно из поля `(*http.Request).Cookie()`, а установить — методом `http.SetCookie()`.

# Инкремент 15 

Сделайте в таблице базы данных с сокращёнными URL дополнительное поле с флагом, 
указывающим на то, что URL должен считаться удалённым. Например, так:

```go
type Storage struct {
    UUID          string  `db:"user_id"`
    ShortURL      string  `db:"short_url"`
    OriginslURL   string  `db:"original_url"`
    DeletedFlag   bool    `db:"is_deleted"`
}
```

Добавьте в сервис новый хендлер `DELETE /api/user/urls`, 
который в теле запроса принимает список идентификаторов сокращённых URL для асинхронного удаления. 
Запрос может быть таким:

```http request
DELETE http://localhost:8080/api/user/urls
Content-Type: application/json

["6qxTVvsy", "RTfd56hn", "Jlfd67ds"]
```

В случае успешного приёма запроса хендлер должен возвращать HTTP-статус `202 Accepted`. 
Фактический результат удаления может происходить позже — оповещать пользователя об успешности или неуспешности не нужно.

Успешно удалить URL может пользователь, его создавший. 
При запросе удалённого URL с помощью хендлера `GET /{id}` нужно вернуть статус `410 Gone`.

Совет:
- Для эффективного проставления флага удаления в БД используйте множественное обновление (batch update).
- Для максимального наполнения буфера объектов обновления используйте паттерн `fanIn`.

# Инкремент 16

С помощью паттерна «Наблюдатель» добавьте в сервис функциональность аудита запросов.
Добавьте в сервер параметры конфигурации:
- Флаг `--audit-file`, переменная окружения `AUDIT_FILE` — путь к файлу-приёмнику, в который сохраняются логи аудита. 
Если параметр не передан, аудит в файл должен быть отключён.
- Флаг `--audit-url`, переменная окружения `AUDIT_URL` — полный URL удаленного сервера-приёмника, куда отправляются логи аудита. 
Если параметр не передан, аудит на удалённый сервер должен быть отключён.

Формат события аудита:
```json lines
{
    "ts": 12345678, // unix timestamp события
    "action": "shorten", // действие: shorten (создание) или follow (прохождение по ссылке)
    "user_id": "12315134", // идентификатор пользователя, если есть
    "url": "https://mylongdomain.com/my/long/path/to/shorten/" // оригинальный (не сокращенный) URL
}
```

Аудитом должны быть покрыты следующие хэндлеры:
- `POST /`
- `POST /api/shorten`
- `GET /{id}`

После успешной обработки запроса к любому из хэндлеров необходимо сформировать сообщение события аудита 
и отправить его во все доступные приёмники аудита.

Для файла-приёмника добавление происходит в конец файла, указанного в параметре конфигурации, 
на новой строке.

Для удалённого сервера-приёмника отсылка выполняется методом `POST` по URL, 
указанному в параметре конфигурации.

# Инкремент 17

Вы писали код в течение нескольких спринтов. 
Сейчас самое время задать себе вопрос: что можно улучшить в производительности и эффективности вашей системы?

Этот инкремент посвящён измерению, анализу и оптимизации: не предполагаем, а проверяем, 
где именно тратятся ресурсы — процессорное время, память — и как сделать проект лучше.

--- 

Добавьте в свой проект бенчмарки, измеряющие скорость выполнения важнейших компонентов вашей системы.

Проведите анализ использования памяти вашим проектом, 
определите и исправьте неэффективные части кода по следующему алгоритму:
1. Используя профилировщик `pprof`, 
сохраните профиль потребления памяти вашим проектом в директорию `profiles` с именем `base.pprof`
2. Изучите полученный профиль:
   - используйте команды `top`, `list`, `web`, `peek` в `pprof`;
   - обратите внимание на количество аллокаций, удерживаемую память и «тяжёлые» функции.
3. Оптимизируйте код, убрав избыточные аллокации или переписав неэффективные участки кода
4. Снимите профиль повторно, сохраните его как `profiles/result.pprof`

Проверьте результат внесённых изменений командой:
```shell
pprof -top -diff_base=profiles/base.pprof profiles/result.pprof
```

Если всё сделано правильно, вы увидите отрицательные значения — показатель того, что использование памяти уменьшилось. 
Добавьте полученный вывод в `README.md`.

## Рекомендации

- Подготовьте тестовые данные, чтобы система обрабатывала непустой и реалистичный набор входных данных.
- Эмулируйте нагрузку, например, используйте инструменты вроде hey, wrk или ab.
- Снимайте профиль во время или сразу после нагрузки, когда память уже занята.

# Инкремент 18

Отформатируйте свой проект с помощью `gofmt` или `goimports`. Убедитесь, что все файлы проекта прошли форматирование.

# Инкремент 19

Добавьте к основным экспортированным методам и переменным (хендлерам, публичным структурам и интерфейсам) 
в вашем проекте документацию в формате `godoc`.

Добавьте примеры работы с эндпоинтами практического трека в формате `example_test.go`.

# Инкремент 20

В директории `cmd` создайте пакет `linter`. В данную директорию добавьте исходный код статического анализатора,
запускаемого с помощью `golang.org/x/tools/go/analysis/singlechecker`.

Требования к анализатору:
- Должен сообщать о наличии в коде проекта использования встроенной функции `panic`
- Должен сообщать о вызове функций `log.Fatal` и/или `os.Exit` вне функции `main` пакета `main`

Исходный код вашего проекта должен проходить проверку созданным анализатором.
Логика работы анализатора должена быть покрыта тестами с использованием пакета
`golang.org/x/tools/go/analysis/analysistest`.

# Инкремент 21

Добавьте к вашему проекту утилиту, которая будет генерировать функции очистки для произвольных структур.

В директории `./cmd/reset/` вашего проекта создайте исполняемый файл `main.go`,
который будет отвечать за генерацию функций. В этом файле реализуйте следующий алгоритм:
- просканировать все пакеты, начиная с корневой директории и ниже;
- для каждого пакета найти все структуры, над которыми стоит комментарий `// generate:reset`;
- для каждой структуры сгенерировать метод `Reset()`;
- все сгенерированные методы для структур одного пакета должны находиться в файле `reset.gen.go` этого же пакета.

Реализация метода `Reset()` должна «сбрасывать» состояние объекта структуры к начальным значениям по следующим правилам:
- примитивы приводятся к своим нулевым значениям: `int` сбрасывается к `0`, `string` сбрасывается в ``,
  `bool` сбрасывается в `false` и так далее;
- слайсы обрезаются по длине, но не зануляются
  (например, поле `strings []string` должно сброситься к `strings[:0]`);
- мапы также очищаются (можно использовать встроенный метод `clear`);
- вложенные структуры, если они обладают методом `Reset()`, должны вызвать этот метод;
- все не `nil` указатели должны сбросить свои значения по правилам выше.

Чтобы лучше понять, о чем идёт речь, рассмотрим пример реализации такого метода для структуры:

```go
// generate:reset
type ResetableStruct struct {
	i     int
	str   string
	strP  *string
	s     []int
	m     map[string]string
	child *ResetableStruct
}
```

Метод сброса для структуры может выглядеть так:

```go
func (rs *ResetableStruct) Reset() {
	if rs == nil {
		return
	}

	rs.i = 0
	rs.str = ""
	if rs.strP != nil {
		*rs.strP = ""
	}
	rs.s = rs.s[:0]
	clear(rs.m)
	if resetter, ok := rs.child.(interface{ Reset() }); ok && rs.child != nil {
		resetter.Reset()
	}
}
```

Для сканирования и поиска структур вы можете воспользоваться инструментами из пакета `go/ast`. 

# Инкремент 22

В уроке про многопоточность мы рассказывали, как с помощью `sync.Pool` можно повторно использовать «тяжёлые» объекты. 
Очень важно перед возвратом объекта в пул выполнять «сброс» его состояния.

В прошлом инкременте мы просили вас реализовать генератор функций сброса для произвольных структур. 
В этом инкременте вам необходимо создать собственную структуру, 
которая будет представлять собой контейнер для таких структур.

Более формально: вам необходимо реализовать структуру с generic-параметром, 
которая сможет хранить в себе объекты одного конкретного типа. 
Более того, такие объекты должны обладать методом `Reset()`, о котором мы рассказывали в прошлом инкременте.

Итоговый файл должен содержать:
- Структуру `Pool` с generic-параметром, который ограничен типами с методом `Reset()`;
- Функцию-конструктор `New`, которая создаёт и возвращает указатель на структуру `Pool`;
- Метод `Get()` структуры `Pool`, который возвращает объект из пула;
- Метод `Put()` структуры `Pool`, который помещает объект в пул.

# Инкремент 23

Добавьте в пакет `cmd/shortener` глобальные переменные:
- `var buildVersion string`,
- `var buildDate string`,
- `var buildCommit string`.
- 
При старте приложения выводите в stdout сообщение в следующем формате:
```text
Build version: <buildVersion> (или "N/A" при отсутствии значения)
Build date: <buildDate> (или "N/A" при отсутствии значения)
Build commit: <buildCommit> (или "N/A" при отсутствии значения)
```

# Инкремент 24

Добавьте в свой код возможность включения HTTPS в веб-сервере.

При передаче флага `-s` или переменной окружения `ENABLE_HTTPS` запускайте сервер с помощью метода 
`http.ListenAndServeTLS` или `tls.Listen`.

# Инкремент 25

Добавьте возможность конфигурации приложения с помощью файла в формате JSON. 
Нужно поддержать все действующие опции приложения. 
Имя файла конфигурации должно задаваться через флаг `-c`/`-config` или переменную окружения `CONFIG`. 
Значения из файла конфигурации должны иметь меньший приоритет, чем флаги или переменные окружения.

Формат файла:

```json lines
{
    "server_address": "localhost:8080", // аналог переменной окружения SERVER_ADDRESS или флага -a
    "base_url": "http://localhost", // аналог переменной окружения BASE_URL или флага -b
    "file_storage_path": "/path/to/file.db", // аналог переменной окружения FILE_STORAGE_PATH или флага -f
    "database_dsn": "", // аналог переменной окружения DATABASE_DSN или флага -d
    "enable_https": true // аналог переменной окружения ENABLE_HTTPS или флага -s
}
```

# Инкремент 26

Сервер должен штатно завершаться по сигналам: `syscall.SIGTERM`, s`yscall.SIGINT`, `syscall.SIGQUIT`.

Все необработанные запросы должны быть обработаны до конца, все несохранённые данные должны быть сохранены в хранилище.

# Инкремент 27

Добавьте в сервер новый эндпоинт `GET /api/internal/stats`, возвращающий в ответ объект:

```json lines
{
    "urls": <int>, // количество сокращённых URL в сервисе
    "users": <int> // количество пользователей в сервисе
}
```

Добавьте в конфигурационный JSON-файл HTTP-сервера поле `trusted_subnet` (тип `string`, переменная окружения 
`TRUSTED_SUBNET`, флаг `-t`), в которое можно передать строковое представление бесклассовой адресации (CIDR).

При запросе эндпоинта `/api/internal/stats` нужно проверять, что переданный в заголовке запроса `X-Real-IP` 
IP-адрес клиента входит в доверенную подсеть, в противном случае возвращать статус ответа `403 Forbidden`.

При пустом значении переменной `trusted_subnet` доступ к эндпоинту должен быть запрещён для любого входящего запроса.

# Инкремент 28

Добавьте возможность выполнять запросы к вашему серверу по протоколу gRPC. 
Наряду с HTTP доступ по протоколу gRPC должен быть обеспечен к следующим хендлерам:
- `POST /api/shorten`
- `GET /<id>`
- `GET /api/user/urls`

Формат взаимодействия:

```protobuf
service ShortenerService {
  rpc ShortenURL (URLShortenRequest) returns (URLShortenResponse);
  rpc ExpandURL (URLExpandRequest) returns (URLExpandResponse);
  rpc ListUserURLs (google.protobuf.Empty) returns (UserURLsResponse);
}

message URLShortenRequest {
  string url = 1;
}

message URLShortenResponse {
  string result = 1;
}

message URLExpandRequest {
  string id = 1;
}

message URLExpandResponse {
  string result = 1;
}


message UserURLsResponse {
  repeated URLData url = 1;
}

message URLData {
  string short_url = 1;
  string original_url = 2;
}
```


Для авторизации используйте `metadata`, передавая авторизационные данные в хедере `authorization`. 
Обеспечьте те же параметры конфигурации gRPC-сервера, что и у HTTP-сервера.

**Совет:** попробуйте сделать HTTP- и gRPC-хендлеры фасадами к общему коду с бизнес-логикой.